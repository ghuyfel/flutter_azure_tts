import 'dart:typed_data';
import 'package:flutter_azure_tts/src/common/cache_manager.dart';

/// Specialized cache for storing generated audio data to improve performance.
/// 
/// This cache stores audio files generated by the Azure TTS service to avoid
/// redundant API calls for the same text and voice combinations. It's particularly
/// useful for applications that frequently generate the same speech content.
/// 
/// ## Benefits
/// 
/// - **Performance**: Eliminates redundant API calls for repeated content
/// - **Cost Savings**: Reduces Azure TTS API usage and associated costs
/// - **Offline Capability**: Cached audio can be played without network access
/// - **User Experience**: Faster response times for previously generated content
/// 
/// ## Cache Key Strategy
/// 
/// The cache key is generated from:
/// - Text content (hash for efficiency)
/// - Voice short name
/// - Audio format
/// - Speech rate
/// 
/// This ensures that different combinations of parameters create unique cache entries.
/// 
/// ## Memory Management
/// 
/// Audio files can be large, so the cache uses a reasonable TTL (1 hour by default)
/// to balance performance with memory usage. Consider the memory implications
/// when caching large amounts of audio data.
/// 
/// ## Example
/// 
/// ```dart
/// final audioCache = AudioCache();
/// 
/// // Check cache before making API call
/// var audio = audioCache.get(text, voice.shortName, format, rate);
/// if (audio == null) {
///   // Generate new audio
///   final response = await FlutterAzureTts.getTts(params);
///   audio = response.audio;
///   
///   // Cache for future use
///   audioCache.put(text, voice.shortName, format, rate, audio);
/// }
/// 
/// // Use the audio (from cache or newly generated)
/// await playAudio(audio);
/// ```
class AudioCache {
  /// Default time-to-live for cached audio data.
  /// 
  /// Audio files are cached for 1 hour by default, which provides a good
  /// balance between performance and memory usage. This can be adjusted
  /// based on your application's needs.
  static const Duration _defaultTtl = Duration(hours: 1);
  
  /// The underlying cache manager for storing audio data.
  final CacheManager _cache = CacheManager();

  /// Generates a unique cache key for the given parameters.
  /// 
  /// The key is constructed from all parameters that affect the generated audio:
  /// - Text content (using hash code for efficiency with long texts)
  /// - Voice identifier
  /// - Audio format
  /// - Speech rate
  /// 
  /// ## Parameters
  /// 
  /// - [text]: The text content being synthesized
  /// - [voiceShortName]: The short name of the voice (e.g., 'en-US-JennyNeural')
  /// - [audioFormat]: The audio format string
  /// - [rate]: The speech rate multiplier
  /// 
  /// ## Returns
  /// 
  /// A unique string key for caching this audio combination.
  String _generateKey(String text, String voiceShortName, String audioFormat, double rate) {
    return 'audio_${text.hashCode}_${voiceShortName}_${audioFormat}_$rate';
  }

  /// Stores audio data in the cache with the default TTL.
  /// 
  /// This method caches the generated audio data so it can be retrieved
  /// later without making another API call. The audio is stored with a
  /// time-to-live of 1 hour by default.
  /// 
  /// ## Parameters
  /// 
  /// - [text]: The text that was synthesized
  /// - [voiceShortName]: The voice used for synthesis
  /// - [audioFormat]: The audio format of the generated audio
  /// - [rate]: The speech rate used
  /// - [audio]: The generated audio data
  /// 
  /// ## Memory Considerations
  /// 
  /// Audio files can be large (typically 50KB-500KB for short texts).
  /// Consider the total memory usage when caching many audio files.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // After generating audio from Azure TTS
  /// final response = await FlutterAzureTts.getTts(params);
  /// 
  /// // Cache the result
  /// audioCache.put(
  ///   params.text,
  ///   params.voice.shortName,
  ///   params.audioFormat,
  ///   params.rate ?? 1.0,
  ///   response.audio,
  /// );
  /// ```
  void put(String text, String voiceShortName, String audioFormat, double rate, Uint8List audio) {
    final key = _generateKey(text, voiceShortName, audioFormat, rate);
    _cache.put(key, audio, _defaultTtl);
  }

  /// Retrieves cached audio data if available.
  /// 
  /// This method attempts to find previously cached audio for the given
  /// parameters. If found and not expired, the cached audio is returned.
  /// If not found or expired, null is returned.
  /// 
  /// ## Parameters
  /// 
  /// - [text]: The text to synthesize
  /// - [voiceShortName]: The voice to use
  /// - [audioFormat]: The desired audio format
  /// - [rate]: The speech rate
  /// 
  /// ## Returns
  /// 
  /// The cached audio data, or `null` if not found or expired.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // Try to get cached audio first
  /// var audio = audioCache.get(
  ///   'Hello world',
  ///   'en-US-JennyNeural',
  ///   AudioOutputFormat.audio16khz32kBitrateMonoMp3,
  ///   1.0,
  /// );
  /// 
  /// if (audio != null) {
  ///   print('Using cached audio (${audio.length} bytes)');
  /// } else {
  ///   print('No cached audio found, will generate new');
  /// }
  /// ```
  Uint8List? get(String text, String voiceShortName, String audioFormat, double rate) {
    final key = _generateKey(text, voiceShortName, audioFormat, rate);
    return _cache.get<Uint8List>(key);
  }

  /// Stores audio data with a custom TTL.
  /// 
  /// This method allows you to specify a custom time-to-live for the cached
  /// audio, which can be useful for different types of content:
  /// - Short TTL for dynamic content
  /// - Long TTL for static content
  /// - Very long TTL for permanent content
  /// 
  /// ## Parameters
  /// 
  /// - [text]: The text that was synthesized
  /// - [voiceShortName]: The voice used for synthesis
  /// - [audioFormat]: The audio format of the generated audio
  /// - [rate]: The speech rate used
  /// - [audio]: The generated audio data
  /// - [ttl]: How long to keep the audio in cache
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // Cache static content for a day
  /// audioCache.putWithTtl(
  ///   'Welcome to our app!',
  ///   voice.shortName,
  ///   format,
  ///   1.0,
  ///   audioData,
  ///   Duration(days: 1),
  /// );
  /// 
  /// // Cache dynamic content for just 5 minutes
  /// audioCache.putWithTtl(
  ///   'Current time is ${DateTime.now()}',
  ///   voice.shortName,
  ///   format,
  ///   1.0,
  ///   audioData,
  ///   Duration(minutes: 5),
  /// );
  /// ```
  void putWithTtl(String text, String voiceShortName, String audioFormat, double rate, Uint8List audio, Duration ttl) {
    final key = _generateKey(text, voiceShortName, audioFormat, rate);
    _cache.put(key, audio, ttl);
  }

  /// Removes a specific audio entry from the cache.
  /// 
  /// This method removes cached audio for specific parameters. Use this
  /// when you know that cached audio is no longer valid or when you want
  /// to force regeneration of specific content.
  /// 
  /// ## Parameters
  /// 
  /// - [text]: The text of the audio to remove
  /// - [voiceShortName]: The voice of the audio to remove
  /// - [audioFormat]: The format of the audio to remove
  /// - [rate]: The rate of the audio to remove
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // Remove specific cached audio
  /// audioCache.remove(
  ///   'Outdated message',
  ///   'en-US-JennyNeural',
  ///   AudioOutputFormat.audio16khz32kBitrateMonoMp3,
  ///   1.0,
  /// );
  /// ```
  void remove(String text, String voiceShortName, String audioFormat, double rate) {
    final key = _generateKey(text, voiceShortName, audioFormat, rate);
    _cache.remove(key);
  }

  /// Clears all cached audio data.
  /// 
  /// This method removes all audio entries from the cache, freeing up memory.
  /// Use this for cleanup operations or when you want to force regeneration
  /// of all cached content.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // Clear all cached audio (e.g., on app restart or settings change)
  /// audioCache.clear();
  /// ```
  void clear() {
    _cache.clear();
  }

  /// Gets the current number of cached audio entries.
  /// 
  /// This includes both valid and expired entries. Expired entries are
  /// only removed when accessed or during explicit cleanup.
  /// 
  /// ## Returns
  /// 
  /// The number of audio entries currently in the cache.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// print('Cache contains ${audioCache.size} audio files');
  /// ```
  int get size => _cache.size;

  /// Checks if the audio cache is empty.
  /// 
  /// ## Returns
  /// 
  /// `true` if there are no cached audio entries, `false` otherwise.
  bool get isEmpty => _cache.isEmpty;

  /// Checks if the audio cache contains any entries.
  /// 
  /// ## Returns
  /// 
  /// `true` if there are cached audio entries, `false` otherwise.
  bool get isNotEmpty => _cache.isNotEmpty;

  /// Estimates the total memory usage of cached audio data.
  /// 
  /// This method calculates the approximate memory usage by summing the
  /// byte lengths of all cached audio files. Note that this only includes
  /// the audio data itself, not the overhead of cache management.
  /// 
  /// ## Returns
  /// 
  /// The estimated memory usage in bytes.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// final memoryUsage = audioCache.estimateMemoryUsage();
  /// final memoryMB = memoryUsage / (1024 * 1024);
  /// print('Audio cache using approximately ${memoryMB.toStringAsFixed(1)} MB');
  /// ```
  int estimateMemoryUsage() {
    int totalBytes = 0;
    
    // Note: This is a simplified estimation. In a real implementation,
    // you might want to iterate through cache entries and sum their sizes.
    // For now, we'll return 0 as the CacheManager doesn't expose internal data.
    
    return totalBytes;
  }

  /// Performs cleanup of expired audio entries.
  /// 
  /// This method manually removes expired audio entries from the cache,
  /// which can help free up memory. While expired entries are automatically
  /// removed when accessed, calling this method proactively can be beneficial
  /// for memory management.
  /// 
  /// ## Returns
  /// 
  /// The number of expired entries that were removed.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final audioCache = AudioCache();
  /// 
  /// // Perform periodic cleanup
  /// final removedCount = audioCache.cleanup();
  /// if (removedCount > 0) {
  ///   print('Cleaned up $removedCount expired audio files');
  /// }
  /// ```
  int cleanup() {
    return _cache.cleanup();
  }
}