import 'dart:async';
import 'dart:typed_data';

/// Represents a chunk of audio data in a streaming response.
/// 
/// Each chunk contains a portion of the generated audio along with metadata
/// about the chunk's position in the overall stream and timing information.
/// 
/// ## Usage
/// 
/// ```dart
/// stream.listen((chunk) {
///   print('Received ${chunk.data.length} bytes at ${chunk.timestamp}');
///   audioPlayer.addChunk(chunk.data);
/// });
/// ```
class AudioChunk {
  /// Creates a new audio chunk.
  /// 
  /// ## Parameters
  /// 
  /// - [data]: The audio data bytes for this chunk
  /// - [sequenceNumber]: The order of this chunk in the stream (0-based)
  /// - [timestamp]: When this chunk was generated
  /// - [isLast]: Whether this is the final chunk in the stream
  const AudioChunk({
    required this.data,
    required this.sequenceNumber,
    required this.timestamp,
    this.isLast = false,
  });

  /// The audio data bytes for this chunk.
  /// 
  /// This contains the actual audio content that can be played or saved.
  /// The format matches the audio format specified in the TTS request.
  final Uint8List data;

  /// The sequence number of this chunk in the stream.
  /// 
  /// Chunks are numbered starting from 0. This can be used to ensure
  /// chunks are processed in the correct order and to detect missing chunks.
  final int sequenceNumber;

  /// When this chunk was generated by the Azure TTS service.
  /// 
  /// This timestamp can be used for synchronization, latency measurement,
  /// or debugging purposes.
  final DateTime timestamp;

  /// Whether this is the final chunk in the stream.
  /// 
  /// When this is `true`, no more chunks will be sent and the stream
  /// should be considered complete.
  final bool isLast;

  /// The size of this chunk in bytes.
  int get size => data.length;

  @override
  String toString() {
    return 'AudioChunk(sequence: $sequenceNumber, size: $size bytes, '
           'timestamp: $timestamp, isLast: $isLast)';
  }
}

/// Streaming audio response that provides real-time audio chunks.
/// 
/// This class represents a streaming response from the Azure TTS service,
/// allowing audio to be played as it's being generated rather than waiting
/// for the complete audio file.
/// 
/// ## Benefits of Streaming
/// 
/// - **Lower Latency**: Audio playback can start immediately
/// - **Better User Experience**: No waiting for long texts to be fully processed
/// - **Memory Efficiency**: Audio is processed in chunks rather than loading everything
/// - **Real-time Feedback**: Progress can be shown to users
/// 
/// ## Usage
/// 
/// ```dart
/// final streamResponse = await FlutterAzureTts.getTtsStream(params);
/// 
/// await for (final chunk in streamResponse.audioStream) {
///   if (chunk.sequenceNumber == 0) {
///     print('First chunk received, starting playback');
///   }
///   
///   audioPlayer.addChunk(chunk.data);
///   
///   if (chunk.isLast) {
///     print('Stream complete');
///     break;
///   }
/// }
/// ```
class AudioStreamResponse {
  /// Creates a new streaming audio response.
  /// 
  /// ## Parameters
  /// 
  /// - [audioStream]: The stream of audio chunks
  /// - [contentType]: The MIME type of the audio content
  /// - [totalEstimatedSize]: Estimated total size in bytes (if available)
  AudioStreamResponse({
    required this.audioStream,
    required this.contentType,
    this.totalEstimatedSize,
  });

  /// Stream of audio chunks as they become available.
  /// 
  /// This stream emits [AudioChunk] objects in sequence as the Azure TTS
  /// service generates the audio. Chunks should be processed in order
  /// based on their sequence numbers.
  /// 
  /// The stream will complete when the last chunk (with `isLast = true`)
  /// is emitted, or if an error occurs during generation.
  final Stream<AudioChunk> audioStream;

  /// The MIME type of the audio content.
  /// 
  /// This corresponds to the audio format specified in the TTS request
  /// (e.g., 'audio/mpeg' for MP3, 'audio/wav' for WAV).
  final String contentType;

  /// Estimated total size of the complete audio in bytes.
  /// 
  /// This is an estimate provided by Azure and may not be exact.
  /// It can be used for progress indication or buffer allocation.
  /// May be `null` if the size cannot be estimated.
  final int? totalEstimatedSize;

  /// Collects all chunks into a single audio buffer.
  /// 
  /// This method consumes the entire stream and concatenates all chunks
  /// into a single [Uint8List]. Use this when you need the complete audio
  /// data rather than streaming playback.
  /// 
  /// ## Returns
  /// 
  /// A [Future] that completes with the complete audio data.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final streamResponse = await FlutterAzureTts.getTtsStream(params);
  /// final completeAudio = await streamResponse.collectBytes();
  /// await File('output.mp3').writeAsBytes(completeAudio);
  /// ```
  Future<Uint8List> collectBytes() async {
    final chunks = <Uint8List>[];
    int totalSize = 0;

    await for (final chunk in audioStream) {
      chunks.add(chunk.data);
      totalSize += chunk.data.length;
      
      if (chunk.isLast) break;
    }

    // Efficiently concatenate all chunks
    final result = Uint8List(totalSize);
    int offset = 0;
    
    for (final chunk in chunks) {
      result.setRange(offset, offset + chunk.length, chunk);
      offset += chunk.length;
    }

    return result;
  }

  /// Creates a broadcast stream that can be listened to multiple times.
  /// 
  /// By default, the audio stream can only be listened to once. This method
  /// creates a broadcast stream that allows multiple listeners, which can be
  /// useful for scenarios like simultaneous playback and saving to file.
  /// 
  /// ## Returns
  /// 
  /// A new [AudioStreamResponse] with a broadcast stream.
  /// 
  /// ## Example
  /// 
  /// ```dart
  /// final streamResponse = await FlutterAzureTts.getTtsStream(params);
  /// final broadcastResponse = streamResponse.asBroadcastStream();
  /// 
  /// // Listen for playback
  /// broadcastResponse.audioStream.listen((chunk) {
  ///   audioPlayer.addChunk(chunk.data);
  /// });
  /// 
  /// // Listen for saving to file
  /// broadcastResponse.audioStream.listen((chunk) {
  ///   fileWriter.writeChunk(chunk.data);
  /// });
  /// ```
  AudioStreamResponse asBroadcastStream() {
    return AudioStreamResponse(
      audioStream: audioStream.asBroadcastStream(),
      contentType: contentType,
      totalEstimatedSize: totalEstimatedSize,
    );
  }
}

/// Progress information for streaming audio generation.
/// 
/// This class provides detailed progress information during streaming
/// audio generation, including timing, throughput, and completion metrics.
/// 
/// ## Usage
/// 
/// ```dart
/// streamResponse.progressStream.listen((progress) {
///   print('Progress: ${progress.percentComplete}%');
///   print('Speed: ${progress.bytesPerSecond} bytes/sec');
/// });
/// ```
class StreamProgress {
  /// Creates a new stream progress object.
  const StreamProgress({
    required this.bytesReceived,
    required this.totalEstimatedBytes,
    required this.chunksReceived,
    required this.elapsedTime,
    required this.isComplete,
  });

  /// Number of audio bytes received so far.
  final int bytesReceived;

  /// Estimated total bytes for the complete audio.
  /// 
  /// May be `null` if the total size cannot be estimated.
  final int? totalEstimatedBytes;

  /// Number of audio chunks received so far.
  final int chunksReceived;

  /// Time elapsed since streaming started.
  final Duration elapsedTime;

  /// Whether the stream has completed.
  final bool isComplete;

  /// Percentage of completion (0.0 to 1.0).
  /// 
  /// Returns `null` if the total size is unknown.
  double? get percentComplete {
    final total = totalEstimatedBytes;
    if (total == null || total == 0) return null;
    return (bytesReceived / total).clamp(0.0, 1.0);
  }

  /// Current throughput in bytes per second.
  /// 
  /// Returns 0 if no time has elapsed.
  double get bytesPerSecond {
    final seconds = elapsedTime.inMilliseconds / 1000.0;
    return seconds > 0 ? bytesReceived / seconds : 0.0;
  }

  /// Current throughput in chunks per second.
  /// 
  /// Returns 0 if no time has elapsed.
  double get chunksPerSecond {
    final seconds = elapsedTime.inMilliseconds / 1000.0;
    return seconds > 0 ? chunksReceived / seconds : 0.0;
  }

  @override
  String toString() {
    final percent = percentComplete;
    final percentStr = percent != null ? '${(percent * 100).toStringAsFixed(1)}%' : 'unknown';
    
    return 'StreamProgress('
           'bytes: $bytesReceived/${totalEstimatedBytes ?? "unknown"}, '
           'chunks: $chunksReceived, '
           'progress: $percentStr, '
           'speed: ${bytesPerSecond.toStringAsFixed(1)} B/s, '
           'complete: $isComplete'
           ')';
  }
}